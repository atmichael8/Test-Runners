<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_DataStuff" Id="{5de43432-b6a0-4bfd-a085-0227690ebfb9}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_DataStuff

VAR
	// original array of the object being created 
	a2dArray : ARRAY[1..1000] OF ARRAY[1..3] OF STRING;
	// the pointer, pointing to the array above because the ADR() is set to the array above
	pPointer : POINTER TO ARRAY[1..1000] OF ARRAY[1..3] OF STRING := ADR(a2dArray);
	
	// The value that will be calculated amongst the runners
	nValueToCalculate : UINT := 100;
	// the pointer that points to the UINT above, seen by setting the ADR() to the variable above
	pPointerToValue : POINTER TO UINT := ADR(nValueToCalculate);

	// This will keep track of the index in which the mStoreData method will place data in
	nIndexCounter : UINT := 0;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[// Track to see if the index counter is within range of the array, if so then execute the code
IF nIndexCounter < 1000 THEN
	// Increment the index counter so that the next runner call places it in the appropriate index of array
	nIndexCounter := nIndexCounter + 1;
	
	// call runner method
	mRunnerOne(TableAddress := pPointer, // forward the memory address of the array   
			   nIndexLocation := nIndexCounter, // forward the corresponding index location
			   RunnerValueAddress := pPointerToValue); // forward the address of the value to be calculated
			  
	// Increment the index counter so that the next runner call places it in the appropriate index of array 
	nIndexCounter := nIndexCounter + 1;
	
	// call runner method
	mRunnerTwo(TableAddress := pPointer,  // forward the memory address of the array   
			   nIndexLocation := nIndexCounter, // forward the corresponding index location
			   RunnerValueAddress := pPointerToValue); // forward the address of the value to be calculated
END_IF

]]></ST>
    </Implementation>
    <Method Name="mRunnerOne" Id="{4c35da92-dbaa-462a-b449-f72ec02b6747}">
      <Declaration><![CDATA[METHOD mRunnerOne : BOOL

VAR_INPUT
	// receive the address of the table from FB_DataStuff
	TableAddress : POINTER TO ARRAY[1..1000] OF ARRAY[1..3] OF STRING;
	
	// receive the address of the value to be calculated by this runner
	RunnerValueAddress : POINTER TO UINT;
	
	// receive the index location in which the calculated value will be stored in the array
	nIndexLocation : UINT;
END_VAR

VAR
	// unique ID for this runner to be stored in the array for tracking purposes
	nThisRunner : UINT := 1;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set the value directly inside the memory address containing said value
RunnerValueAddress^ := RunnerValueAddress^ + 1;

// call the store data method
mStoreData(StoreTableAddress := TableAddress, // forward the mem address of the data to store method
		   nIndexToStoreIn := nIndexLocation, // forward desired index to store this info in
		   nValue := RunnerValueAddress^, // forward the data inside the memory address to the store method 
		   nRunnerNumber := nThisRunner); // send unique ID for recording purposes
		   
// The same notes and principles apply as they did for the pass by reference. The only difference
// here is that now the address is of concern and must be handled. This increases the risk
// because not only are the values inside being directly accessed by multiple functions
// but now the memory addresses themselves can be affected. If there is an error in writing
// the code, it could potentially access memory out of bounds, or delete memory of another variable
// troubleshooting that would be difficult because it is affecting a memory address which can
// change from runtime to runtime depending on the circumstances, leading to the unexpected outcome
// to appear random, when it is actually the same error occuring, but with a different address and
// thus a different variable. ]]></ST>
      </Implementation>
    </Method>
    <Method Name="mRunnerTwo" Id="{017cb03a-c4b4-4fa7-be8a-82cf29a99e89}">
      <Declaration><![CDATA[METHOD mRunnerTwo : BOOL

VAR_INPUT
	// receive the address of the table from FB_DataStuff
	TableAddress : POINTER TO ARRAY[1..1000] OF ARRAY[1..3] OF STRING;
	
	// receive the address of the value to be calculated by this runner
	RunnerValueAddress : POINTER TO UINT;
	
	// receive the index location in which the calculated value will be stored in the array
	nIndexLocation : UINT;
END_VAR

VAR
	// unique ID for this runner to be stored in the array for tracking purposes
	nThisRunner : UINT := 2;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// set the value directly inside the memory address containing said value
RunnerValueAddress^ := RunnerValueAddress^ - 1;

// call the store data method
mStoreData(StoreTableAddress := TableAddress, // forward the mem address of the data to store method
		   nIndexToStoreIn := nIndexLocation, // forward desired index to store this info in
		   nValue := RunnerValueAddress^, // forward the data inside the memory address to the store method
		   nRunnerNumber := nThisRunner); // send unique ID for recording purposes
		   
// The same notes and principles apply as they did for the pass by reference. The only difference
// here is that now the address is of concern and must be handled. This increases the risk
// because not only are the values inside being directly accessed by multiple functions
// but now the memory addresses themselves can be affected. If there is an error in writing
// the code, it could potentially access memory out of bounds, or delete memory of another variable
// troubleshooting that would be difficult because it is affecting a memory address which can
// change from runtime to runtime depending on the circumstances, leading to the unexpected outcome
// to appear random, when it is actually the same error occuring, but with a different address and
// thus a different variable. ]]></ST>
      </Implementation>
    </Method>
    <Method Name="mStoreData" Id="{7643b4a4-143b-4065-9533-062b0b195bbd}">
      <Declaration><![CDATA[METHOD mStoreData : BOOL

VAR_INPUT
	// Address of the array in FB_DataStuff
	StoreTableAddress : POINTER TO ARRAY[1..1000] OF ARRAY[1..3] OF STRING;
	
	// The desired index being passed from FB)DataStuff -> mRunner(number) -> here
	nIndexToStoreIn : UINT;
	
	// The value that was calculated by whichever runner calling this method (not pointed to, so not most up to date)
	nValue : UINT;
	
	// The unique ID sent by whichever unique runner calling this method
	nRunnerNumber : UINT;
END_VAR

VAR
	// The strings which will be sent to the array after converting from their original value
	sCurrentStringA : STRING;
	sCurrentStringB : STRING;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Convert the respective inputs to string in order to be stored in the array : STRING
sCurrentStringA := UINT_TO_STRING(nValue);
sCurrentStringB := UINT_TO_STRING(nRunnerNumber);

// Dereference the pointer with ^ in order to denote that its the data within the address that 
//  the pointer is pointing to
StoreTableAddress^[nIndexToStoreIn][1] := sCurrentStringA;
StoreTableAddress^[nIndexToStoreIn][2] := sCurrentStringB;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_DataStuff">
      <LineId Id="96" Count="16" />
      <LineId Id="42" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="31" Count="0" />
    </LineIds>
    <LineIds Name="FB_DataStuff.mRunnerOne">
      <LineId Id="100" Count="16" />
      <LineId Id="67" Count="0" />
    </LineIds>
    <LineIds Name="FB_DataStuff.mRunnerTwo">
      <LineId Id="90" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_DataStuff.mStoreData">
      <LineId Id="105" Count="7" />
      <LineId Id="49" Count="0" />
      <LineId Id="32" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>